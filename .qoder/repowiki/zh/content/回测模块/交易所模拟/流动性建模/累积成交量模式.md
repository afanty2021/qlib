# 累积成交量模式

<cite>
**本文档中引用的文件**  
- [exchange.py](file://qlib/backtest/exchange.py)
- [high_freq.py](file://qlib/contrib/ops/high_freq.py)
</cite>

## 目录
1. [简介](#简介)
2. [核心机制解析](#核心机制解析)
3. [自定义算子实现](#自定义算子实现)
4. [使用示例与注册](#使用示例与注册)
5. [市场时段适应性](#市场时段适应性)
6. [性能优化建议](#性能优化建议)

## 简介
本文档深入解析流动性建模中'cum'模式的实现机制，重点阐述如何基于历史成交量的累积值动态计算可交易数量上限。详细说明volume_threshold参数在该模式下的行为逻辑，结合DayCumsum等自定义算子展示其在防止过度成交中的应用。

## 核心机制解析
在Qlib框架中，'cum'模式通过`Exchange`类的`_clip_amount_by_volume`方法实现。当订单方向为买入时，系统会获取`buy_vol_limit`；当为卖出时，则获取`sell_vol_limit`。对于"cum"类型的限制，系统首先通过`quote.get_data`获取指定字段的最后数据值，然后减去已成交的订单金额(dealt_order_amount)，从而得到当前可用的交易额度。

```python
elif limit[0] == "cum":
    limit_value = self.quote.get_data(
        order.stock_id,
        order.start_time,
        order.end_time,
        field=limit[1],
        method="ts_data_last",
    )
    vol_limit_num.append(limit_value - dealt_order_amount[order.stock_id])
```

最终，系统取所有限制条件中的最小值作为实际执行的交易量，并确保交易量不会低于零。

**Section sources**
- [exchange.py](file://qlib/backtest/exchange.py#L785-L831)

## 自定义算子实现
DayCumsum算子继承自ElemOperator，用于计算特定时间段内的日累计值。该算子接受三个主要参数：特征(feature)、开始时间(start)和结束时间(end)。在初始化过程中，它会将输入的时间字符串转换为datetime对象，并确定交易时段的边界。

```python
def __init__(self, feature, start: str = "9:30", end: str = "14:59", data_granularity: int = 1):
    self.feature = feature
    self.start = datetime.strptime(start, "%H:%M")
    self.end = datetime.strptime(end, "%H:%M")
    # ... 其他初始化代码
```

核心的累计计算由`period_cusum`方法完成，该方法首先将非交易时段的数据置零，然后进行累计求和，最后再次将超出交易时段的数据置零。

**Section sources**
- [high_freq.py](file://qlib/contrib/ops/high_freq.py#L49-L98)

## 使用示例与注册
要使用DayCumsum等自定义算子，需要先在qlib_init中进行注册。典型的volume_threshold配置如下：

```python
"volume_threshold": {
    "all": ("cum", "0.2 * DayCumsum($volume, '9:45', '14:45')"),
    "buy": ("current", "$askV1"),
    "sell": ("current", "$bidV1"),
}
```

在这个配置中：
- "all"表示买卖都适用的限制
- "cum"表示这是一个随时间累积的值
- "current"表示这是一个实时值
- 不同的限制条件会通过min()函数进行聚合

**Section sources**
- [exchange.py](file://qlib/backtest/exchange.py#L81-L112)

## 市场时段适应性
DayCumsum算子特别适用于处理开盘集合竞价后的市场情况。通过设置合理的开始和结束时间（如"9:45"到"14:45"），可以有效避免因集合竞价期间异常成交量导致的过度交易。算子内部定义了上午开盘(9:30)、上午收盘(11:30)、下午开盘(13:00)和下午收盘(15:00)等关键时间点，能够准确识别并处理A股市场的交易时段。

此外，该算子还支持数据粒度(data_granularity)参数，使其能够适应不同频率的数据（如1分钟、5分钟等），增强了在不同市场环境下的适应性。

**Section sources**
- [high_freq.py](file://qlib/contrib/ops/high_freq.py#L49-L98)

## 性能优化建议
为了减少重复计算开销，建议采用以下性能优化策略：

1. **数据预加载**：利用`get_calendar_day`函数配合内存缓存(H)来预先加载高频日历数据，避免每次调用时重新计算。
```python
if flag in H["c"]:
    _calendar = H["c"][flag]
else:
    _calendar = np.array(list(map(lambda x: x.date(), Cal.load_calendar(freq, future))))
    H["c"][flag] = _calendar
```

2. **缓存策略**：充分利用Qlib内置的缓存机制，特别是H字典，将频繁访问的数据存储在内存中。

3. **批量处理**：尽可能使用groupby和transform等向量化操作，而不是逐行处理数据。

4. **合理设置时间窗口**：根据实际需求精确设置start和end时间，避免不必要的数据加载和计算。

这些优化措施可以显著提升高频交易场景下的计算效率。

**Section sources**
- [high_freq.py](file://qlib/contrib/ops/high_freq.py#L1-L48)